"use strict";

/**
 * üåê MULTINODAL REDIS CONFIGURATION
 * By PunkClaude - October 2025
 *
 * MISSION: Configure Redis for multinodal swarm operations
 * STRATEGY: Set environment variables for shared Redis instance
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * üîß Configure Redis for multinodal operations
 */
class MultinodalRedisConfigurator {
    constructor() {
        this.configPath = path.join(process.cwd(), '.env');
        this.backupPath = path.join(process.cwd(), '.env.backup');
        this.redisHost = process.env.REDIS_HOST || this.detectRedisHost();
        this.redisPort = process.env.REDIS_PORT || '6379';
        this.redisPassword = process.env.REDIS_PASSWORD || '';
        this.redisDb = process.env.REDIS_DB || '0';
    }

    /**
     * üîç Detect available Redis host for multinodal setup
     */
    detectRedisHost() {
        // Priority: Environment > Docker network > Localhost
        if (process.env.REDIS_HOST) return process.env.REDIS_HOST;

        // Check for Docker network Redis
        try {
            // In Docker Compose, Redis might be available at 'redis' hostname
            const dockerRedis = 'redis';
            console.log(`üîç Detected potential Docker Redis host: ${dockerRedis}`);
            return dockerRedis;
        } catch (error) {
            console.log('‚ö†Ô∏è Docker Redis detection failed, using localhost');
            return 'localhost';
        }
    }

    /**
     * üìù Generate multinodal Redis configuration
     */
    generateConfig() {
        const config = `# üåê MULTINODAL REDIS CONFIGURATION - Generated by PunkClaude
# This configuration enables multinodal swarm operations
# All nodes will connect to the same Redis instance for shared state

# Redis Connection Settings
REDIS_HOST=${this.redisHost}
REDIS_PORT=${this.redisPort}
REDIS_PASSWORD=${this.redisPassword}
REDIS_DB=${this.redisDb}

# Multinodal Swarm Settings
SWARM_MODE=multinodal
VITALS_SHARING=enabled
CONSENSUS_MODE=distributed

# Node Identification (auto-generated per instance)
NODE_ID=selene-${process.pid}-${Date.now()}
NODE_ROLE=worker
NODE_ZONE=default

# Vitals Publishing Settings
VITALS_PUBLISH_INTERVAL=5000
VITALS_TTL=30000
VITALS_KEY_PREFIX=dentiagest:swarm:vitals:

# Consensus Settings
CONSENSUS_CACHE_TTL=60000
QUORUM_THRESHOLD=0.51

# Debug Settings
DEBUG_SWARM=true
DEBUG_CONSENSUS=true
DEBUG_REDIS=true
`;

        return config;
    }

    /**
     * üíæ Backup existing .env file
     */
    backupExistingConfig() {
        if (fs.existsSync(this.configPath)) {
            console.log('üìã Backing up existing .env file...');
            fs.copyFileSync(this.configPath, this.backupPath);
            console.log('‚úÖ Backup created:', this.backupPath);
            return true;
        }
        return false;
    }

    /**
     * üîß Apply multinodal Redis configuration
     */
    applyConfiguration() {
        console.log('üåê CONFIGURING REDIS FOR MULTINODAL OPERATIONS');
        console.log('‚îÅ'.repeat(60));

        // Backup existing config
        const hadBackup = this.backupExistingConfig();

        // Generate new config
        const config = this.generateConfig();

        // Write configuration
        fs.writeFileSync(this.configPath, config, 'utf8');
        console.log('‚úÖ Multinodal Redis configuration applied');
        console.log(`üìç Configuration file: ${this.configPath}`);

        if (hadBackup) {
            console.log(`üìã Original config backed up to: ${this.backupPath}`);
        }

        // Display configuration summary
        console.log('\nüîß CONFIGURATION SUMMARY:');
        console.log(`   Redis Host: ${this.redisHost}`);
        console.log(`   Redis Port: ${this.redisPort}`);
        console.log(`   Swarm Mode: multinodal`);
        console.log(`   Vitals Sharing: enabled`);
        console.log(`   Node ID: selene-${process.pid}-*`);

        console.log('\nüéØ NEXT STEPS:');
        console.log('   1. Restart your application to load new environment variables');
        console.log('   2. Verify Redis connectivity: docker-compose exec redis redis-cli ping');
        console.log('   3. Check swarm logs for multinodal vitals sharing');

        return {
            success: true,
            configPath: this.configPath,
            backupPath: hadBackup ? this.backupPath : null,
            redisHost: this.redisHost,
            redisPort: this.redisPort
        };
    }

    /**
     * üîÑ Restore original configuration
     */
    restoreConfiguration() {
        if (fs.existsSync(this.backupPath)) {
            console.log('üîÑ Restoring original .env configuration...');
            fs.copyFileSync(this.backupPath, this.configPath);
            console.log('‚úÖ Original configuration restored');
            return true;
        } else {
            console.log('‚ö†Ô∏è No backup file found to restore');
            return false;
        }
    }

    /**
     * üß™ Test Redis connectivity
     */
    async testConnectivity() {
        console.log('üß™ Testing Redis connectivity...');

        try {
            // Try Docker Redis first
            const { createClient } = await import('redis');
            const client = createClient({
                host: this.redisHost,
                port: parseInt(this.redisPort),
                password: this.redisPassword || undefined,
                database: parseInt(this.redisDb),
            });

            await client.connect();
            const pong = await client.ping();
            await client.disconnect();

            console.log(`‚úÖ Redis connectivity test PASSED: ${pong}`);
            return true;
        } catch (error) {
            console.log(`‚ùå Redis connectivity test FAILED:`, error.message);
            console.log('üí° Possible solutions:');
            console.log('   - Start Redis: docker-compose up -d redis');
            console.log('   - Check Redis password if required');
            console.log('   - Verify network connectivity in Docker/container setup');
            return false;
        }
    }
}

/**
 * üöÄ Main execution
 */
async function main() {
    const configurator = new MultinodalRedisConfigurator();

    console.log('üåê MULTINODAL REDIS CONFIGURATOR');
    console.log('By PunkClaude - October 2025');
    console.log('‚îÅ'.repeat(60));

    // Test connectivity first
    const isConnected = await configurator.testConnectivity();
    if (!isConnected) {
        console.log('\n‚ö†Ô∏è Redis connectivity test failed!');
        console.log('Please start Redis with: docker-compose up -d redis');
        console.log('Then re-run this configuration script.');
        // Don't exit, allow configuration even if Redis isn't running yet
    }

    // Apply configuration
    const result = configurator.applyConfiguration();

    if (result.success) {
        console.log('\nüéâ MULTINODAL REDIS CONFIGURATION COMPLETE!');
        console.log('Your swarm is now ready for multinodal operations.');
    } else {
        console.log('\n‚ùå Configuration failed!');
        process.exit(1);
    }
}

// Export for programmatic use
export { MultinodalRedisConfigurator };

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
    main().catch(console.error);
}